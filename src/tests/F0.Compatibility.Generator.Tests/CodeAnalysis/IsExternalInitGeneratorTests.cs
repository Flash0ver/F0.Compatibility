using F0.CodeAnalysis;
using F0.Tests.Testing;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Testing;

namespace F0.Tests.CodeAnalysis;

public class IsExternalInitGeneratorTests
{
	private static readonly ReferenceAssemblies withoutIsExternalInit = ReferenceAssemblies.NetCore.NetCoreApp31;
	private static readonly ReferenceAssemblies withIsExternalInit = ReferenceAssemblies.Net.Net50;

	[Theory]
	[MemberData(nameof(InitOnlySetter_TheoryData))]
	public async Task SingleInitOnlySetter_Compile_GenerateType(string code, LanguageVersion langVersion)
	{
		await VerifyAsync(code, withIsExternalInit, langVersion);
		await VerifyAsync(code, GetGenerated(langVersion), withoutIsExternalInit, langVersion);
	}

	[Fact]
	public async Task MultipleInitOnlySetter_Compile_GenerateType()
	{
		const string code = """
			public class Class { public string InitOnlySetter { get; init; } }
			public struct Struct { public string InitOnlySetter { get; init; } }
			public readonly struct ReadOnlyStruct { public string InitOnlySetter { get; init; } }
			public record Record(string InitOnlySetter);
			public record class ReferenceType(string InitOnlySetter);
			public readonly record struct ValueType(string InitOnlySetter);
			""";

		await VerifyAsync(code, withIsExternalInit);
		await VerifyAsync(code, GetGenerated(), withoutIsExternalInit);
	}

	[Fact]
	public async Task NoInitOnlySetter_Compile_DoNotGenerateType()
	{
		const string code = """
			public class SetAccessor { public string InitOnlySetter { get; set; } }
			public class NoSetAccessor { public string InitOnlySetter { get; } }
			public record Record();
			public record class ReferenceType();
			public record struct ValueType(string InitOnlySetter);
			""";

		await VerifyAsync(code, withoutIsExternalInit);
	}

	[Fact]
	public async Task TypeAlreadyDefined_Compile_DoNotGenerateType()
	{
		const string code = """
			public record Record(string InitOnlySetter);

			namespace System.Runtime.CompilerServices
			{
				internal static class IsExternalInit
				{
				}
			}
			""";

		await VerifyAsync(code, withoutIsExternalInit);
	}

	[Fact]
	public async Task TypeNotYetImplemented_Compile_GenerateType()
	{
		const string code = """
			public record Record(string InitOnlySetter);

			namespace System.Runtime.Namespace
			{
				internal static class IsExternalInit
				{
				}
			}
			namespace System.Runtime.CompilerServices
			{
				internal static class ExternalInit
				{
				}
			}
			""";

		await VerifyAsync(code, GetGenerated(), withoutIsExternalInit);
	}

	[Fact]
	public async Task NotSupported_Compile_DoNotGenerateType()
	{
		const string code = """
			public class Class
			{
				public string InitOnlySetter { get; {|#0:init|}; }
			}
			""";

		DiagnosticResult[] diagnostics =
		{
			CreateError("CS8400").WithLocation(0).WithArguments("init-only setters", "9.0"),
			CreateError("CS0518").WithLocation(0).WithArguments("System.Runtime.CompilerServices.IsExternalInit"),
		};

		await VerifyAsync(code, withoutIsExternalInit, LanguageVersion.CSharp8, diagnostics);
	}

	public static TheoryData<string, LanguageVersion> InitOnlySetter_TheoryData()
	{
		return new()
		{
			{ "public class Class { public string InitOnlySetter { get; init; } }", LanguageVersion.CSharp9 },
			{ "public struct Struct { public string InitOnlySetter { get; init; } }", LanguageVersion.CSharp9 },
			{ "public readonly struct ReadOnlyStruct { public string InitOnlySetter { get; init; } }", LanguageVersion.CSharp9 },

			{ "public record Record(string InitOnlySetter);", LanguageVersion.CSharp9 },
			{ "public record class ReferenceType(string InitOnlySetter);", LanguageVersion.CSharp10 },
			{ "public readonly record struct ValueType(string InitOnlySetter);", LanguageVersion.CSharp10 }
		};
	}

	private static string GetGenerated(LanguageVersion langVersion = LanguageVersion.Latest)
	{
		string generated = langVersion switch
		{
			<= LanguageVersion.CSharp8 => throw new ArgumentOutOfRangeException(nameof(langVersion), langVersion, $"Invalid {nameof(LanguageVersion)}."),
			LanguageVersion.CSharp9 => $$"""
				// <auto-generated/>
				#nullable enable

				namespace System.Runtime.CompilerServices
				{
					[global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{typeof(IsExternalInitGenerator).Assembly.GetName().Name}}", "{{typeof(IsExternalInitGenerator).Assembly.GetName().Version}}")]
					internal static class IsExternalInit
					{
					}
				}

				""",
			>= LanguageVersion.CSharp10 => $$"""
				// <auto-generated/>
				#nullable enable

				namespace System.Runtime.CompilerServices;

				[global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{typeof(IsExternalInitGenerator).Assembly.GetName().Name}}", "{{typeof(IsExternalInitGenerator).Assembly.GetName().Version}}")]
				internal static class IsExternalInit
				{
				}

				""",
			_ => throw new ArgumentOutOfRangeException(nameof(langVersion), langVersion, $"Invalid {nameof(LanguageVersion)}."),
		};

		return generated;
	}

	private static DiagnosticResult CreateError(string id)
		=> CSharpIncrementalGeneratorVerifier<IsExternalInitGenerator>.Diagnostic(id, DiagnosticSeverity.Error);

	private static Task VerifyAsync(string test, ReferenceAssemblies refAssemblies, LanguageVersion? langVersion = null)
		=> CSharpIncrementalGeneratorVerifier<IsExternalInitGenerator>.VerifyGeneratorAsync(test, refAssemblies, langVersion);

	private static Task VerifyAsync(string test, string expected, ReferenceAssemblies refAssemblies, LanguageVersion? langVersion = null)
	{
		string filename = "IsExternalInit.g.cs";
		string content = expected;

		return CSharpIncrementalGeneratorVerifier<IsExternalInitGenerator>.VerifyGeneratorAsync(test, (filename, content), refAssemblies, langVersion);
	}

	private static Task VerifyAsync(string test, ReferenceAssemblies refAssemblies, LanguageVersion? langVersion, DiagnosticResult[] diagnostics)
		=> CSharpIncrementalGeneratorVerifier<IsExternalInitGenerator>.VerifyGeneratorAsync(test, diagnostics, refAssemblies, langVersion);
}
