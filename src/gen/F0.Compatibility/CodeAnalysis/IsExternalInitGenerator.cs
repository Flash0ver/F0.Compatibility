using System.Collections.Immutable;
using System.Diagnostics;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace F0.CodeAnalysis;

[Generator]
internal sealed class IsExternalInitGenerator : IIncrementalGenerator
{
	private const string HintName = "IsExternalInit.g.cs";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		IncrementalValuesProvider<SyntaxNode> declarations = context.SyntaxProvider.CreateSyntaxProvider(SyntaxProviderPredicate, SyntaxProviderTransform);

		IncrementalValueProvider<(Compilation, ImmutableArray<SyntaxNode>)> source = context.CompilationProvider.Combine(declarations.Collect());

		context.RegisterSourceOutput(source, SourceOutputAction);
	}

	private static bool SyntaxProviderPredicate(SyntaxNode syntaxNode, CancellationToken cancellationToken)
	{
		return syntaxNode switch
		{
			AccessorDeclarationSyntax accessor when accessor.Keyword.IsKind(SyntaxKind.InitKeyword) => true,
			RecordDeclarationSyntax record when record is
			{
				ParameterList.Parameters.Count: > 0,
			} && RequiresIsExternalInit(record) => true,
			_ => false,
		};

		static bool RequiresIsExternalInit(RecordDeclarationSyntax record)
		{
			if (record.ClassOrStructKeyword.IsKind(SyntaxKind.ClassKeyword))
			{
				return true;
			}

			if (record.ClassOrStructKeyword.IsKind(SyntaxKind.StructKeyword))
			{
				return record.Modifiers.Any(modifier => modifier.IsKind(SyntaxKind.ReadOnlyKeyword));
			}

			Debug.Fail($"Unmatched value: {record}");
			return false;
		}
	}

	private static SyntaxNode SyntaxProviderTransform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
	{
		Debug.Assert(context.Node is AccessorDeclarationSyntax or RecordDeclarationSyntax);

		return context.Node;
	}

	private static void SourceOutputAction(SourceProductionContext context, (Compilation Compilation, ImmutableArray<SyntaxNode> Nodes) source)
	{
		const string sourceText = @"// <auto-generated/>
#nullable enable

namespace System.Runtime.CompilerServices
{
	internal static class IsExternalInit
	{
	}
}
";

		if (source.Nodes.IsDefaultOrEmpty || HasIsExternalInit(source.Compilation))
		{
			return;
		}

		context.AddSource(HintName, sourceText);
	}

	private static bool HasIsExternalInit(Compilation compilation)
	{
		INamedTypeSymbol? type = compilation.GetTypeByMetadataName("System.Runtime.CompilerServices.IsExternalInit");

		return type is not null;
	}
}
